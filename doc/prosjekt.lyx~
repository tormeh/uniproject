#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble

\lstdefinelanguage{scala}{
  morekeywords={abstract,case,catch,class,def,%
    do,else,extends,false,final,finally,%
    for,if,implicit,import,match,mixin,%
    new,null,object,override,package,%
    private,protected,requires,return,sealed,%
    super,this,throw,trait,true,try,%
    type,val,var,while,with,yield},
  otherkeywords={=>,<-,<\%,<:,>:,\#,@},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Light Weight Threads
\end_layout

\begin_layout Author
Tormod Hellen
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newpage
\end_layout

\end_inset


\end_layout

\begin_layout Part
Goals
\end_layout

\begin_layout Standard
The goals of this project is to:
\end_layout

\begin_layout Enumerate
Give a desciption of the paradigms relevant to safe concurrency
\end_layout

\begin_layout Enumerate
Present the leading edge of implementations and other things that should
 influence a modern concurrency abstraction framework
\end_layout

\begin_layout Enumerate
Give an overview over how threads, channels etc.
 are implemented in modern implementations
\end_layout

\begin_layout Enumerate
Propose a solution for concurrency in C
\end_layout

\begin_layout Enumerate
Prototype the solution mentioned
\end_layout

\begin_layout Part
Background
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
There are many models of concurrency awailable to the modern engineer.
 The classic semaphore and its relative - lock - are the most native to
 the way our processors look, with shared memory between thread hardware.
 Others, like the actor model, copy a distributed architecture with several
 computers, all with their own memory, processors and network connections.
 Others still, like channel-concurrency, are based on formal or mathematical
 theorems.
 These are the three main means of concurrency, though others have been
 introduced.
 We will look at some of them here.
\end_layout

\begin_layout Subsection
Tl;DR
\end_layout

\begin_layout Itemize

\emph on
Semaphore
\emph default
: C, C++, Java etc.
 implement this style of concurrency.
 
\end_layout

\begin_layout Itemize

\emph on
Channel
\emph default
: This is the CSP family and its derivatives.
 Go, Rust and Occam have concurrency mechanisms based on channels.
 Focus on being deterministic and formally analyzable.
 Uses multi-sender, multi-receiver (first to read) synchronous channels.
\end_layout

\begin_layout Itemize

\emph on
Actor
\emph default
: Erlang and Akka implement this model.
 Intuitively suited for making distributed systems, with a focus on fault
 tolerance rather than fault avoidance.
 Both implementations eschew sophisticated error recovery mechanisms and
 instead prefer crashing and rebooting errant processes, a philosophy called
 
\begin_inset Quotes eld
\end_inset

let it crash
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
Pipelining: LabView uses this.
 Each thread has one or more pipelines to and from other threads.
 Uses one-way, single sender, single receiver message passing called pipes.
\end_layout

\begin_layout Itemize
Synchronous execution: Threads execute in synchrony, resulting in complete
 determinism.
 Esterel uses this.
\end_layout

\begin_layout Section
CSP Theory
\end_layout

\begin_layout Standard
The Communicating Sequential Processes theory describes a way for parallel
 computation to be done in which the traditional shared-memory errors like
 race conditions are not possible.
 CSP introduces processes and events.
 
\end_layout

\begin_layout Section
Scala with Akka
\begin_inset Index idx
status open

\begin_layout Plain Layout
Akka
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Scala
\end_layout

\end_inset


\end_layout

\begin_layout Quote
\begin_inset Quotes eld
\end_inset

We believe that writing correct concurrent, fault-tolerant and scalable
 applications is too hard.
 Most of the time it's because we are using the wrong tools and the wrong
 level of abstraction.
 Akka is here to change that.
 Using the Actor Model we raise the abstraction level and provide a better
 platform to build scalable, resilient and responsive applicationsâ€”see the
 Reactive Manifesto for more details.
 For fault-tolerance we adopt the "let it crash" model which the telecom
 industry has used with great success to build applications that self-heal
 and systems that never stop.
 Actors also provide the abstraction for transparent distribution and the
 basis for truly scalable and fault-tolerant applications.
\begin_inset Quotes erd
\end_inset

 - The Akka documentation
\end_layout

\begin_layout Standard
Scala originally had its own message passing library, but this has been
 deprecated in favor of the Akka library, which is included as standard
 in all recent distributions of Scala.
 The Akka actor library is an improvement on the Scala actor library which
 in turn is based on the Erlang actor model.
\end_layout

\begin_layout Subsection
Use
\end_layout

\begin_layout Standard
It's used like this:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,frame=lrtb,language=scala,numbers=left"
inline false
status open

\begin_layout Plain Layout

import akka.actor.Actor 
\end_layout

\begin_layout Plain Layout

import akka.actor.ActorRef 
\end_layout

\begin_layout Plain Layout

import akka.actor.ActorSystem 
\end_layout

\begin_layout Plain Layout

import akka.actor.Props 
\end_layout

\begin_layout Plain Layout

import scala.sys 
\end_layout

\begin_layout Plain Layout

import java.lang.Thread
\end_layout

\begin_layout Plain Layout

//Type declarations look like this: "nameOfObject:NameOfClass" with or without
 space.
\end_layout

\begin_layout Plain Layout

class DemoActor(printstr:String) extends Actor 
\end_layout

\begin_layout Plain Layout

{  
\end_layout

\begin_layout Plain Layout

  def receive = 
\end_layout

\begin_layout Plain Layout

  {     
\end_layout

\begin_layout Plain Layout

    case other: ActorRef =>
\end_layout

\begin_layout Plain Layout

    {     	
\end_layout

\begin_layout Plain Layout

      println(printstr)     	
\end_layout

\begin_layout Plain Layout

      other ! self      
\end_layout

\begin_layout Plain Layout

    }     
\end_layout

\begin_layout Plain Layout

    case _       => println("unknown message")   
\end_layout

\begin_layout Plain Layout

  } 
\end_layout

\begin_layout Plain Layout

}   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

object Main extends App 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout

  val system = ActorSystem("DemoSystem")     
\end_layout

\begin_layout Plain Layout

  val aActor = system.actorOf(Props(classOf[DemoActor], "a"))   
\end_layout

\begin_layout Plain Layout

  val bActor = system.actorOf(Props(classOf[DemoActor], "b"))   
\end_layout

\begin_layout Plain Layout

  aActor ! bActor   
\end_layout

\begin_layout Plain Layout

  Thread.sleep(3)   //let actors run for 3 milliseconds
\end_layout

\begin_layout Plain Layout

  scala.sys.exit() 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The output of this is a sequence of type 
\begin_inset Quotes eld
\end_inset

a b a b a b
\begin_inset Quotes erd
\end_inset

 with each letter on a line of its own.
 The precise number of a's and b's printed to the console varies, but in
 general you don't have to scroll if your console is maximised.
 In another example, creating a million Akka actors in Scala takes about
 11 to 12 seconds on the lab computers.
\end_layout

\begin_layout Standard
Synchronous messaging is neither enforced nor recommended by the Akka developers
, but you can use bounded and blocking mailboxes.
 A bounded and blocking mailbox will block the sender of a message if the
 receiver's message queue is full but the minimum capacity is 1, so true
 synchrony is not achieved.
 To achieve true synchrony you need to manually use Await for each time
 you send a message.
 The reason it is not recommended is that new classes of bugs surface, something
 that might be advantageous to a life-critical application programmer, but
 not to the vast majority of programmers.
\end_layout

\begin_layout Standard
In Akka, futures are used by default to avoid blocking when waiting for
 a response, effectively allowing an actor to process several messages concurren
tly, if it needs to.
 This dramatically increases the complexity required to produce a deadlock,
 and does away with the classical 
\begin_inset Quotes eld
\end_inset

A waits on B and B waits on A
\begin_inset Quotes erd
\end_inset

 example entirely.
 For instance this program...
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,frame=lrtb,language=scala,numbers=left"
inline false
status open

\begin_layout Plain Layout

import akka.actor.Actor 
\end_layout

\begin_layout Plain Layout

import akka.actor.ActorRef 
\end_layout

\begin_layout Plain Layout

import akka.actor.ActorSystem 
\end_layout

\begin_layout Plain Layout

import akka.actor.Props 
\end_layout

\begin_layout Plain Layout

import scala.sys 
\end_layout

\begin_layout Plain Layout

import java.lang.Thread 
\end_layout

\begin_layout Plain Layout

import scala.collection.mutable.ArrayBuffer 
\end_layout

\begin_layout Plain Layout

import scala.util.Random 
\end_layout

\begin_layout Plain Layout

import akka.util.Timeout 
\end_layout

\begin_layout Plain Layout

import scala.concurrent._ 
\end_layout

\begin_layout Plain Layout

import scala.concurrent.ExecutionContext.Implicits.global 
\end_layout

\begin_layout Plain Layout

import scala.language.postfixOps 
\end_layout

\begin_layout Plain Layout

import akka.pattern.ask import scala.util.{Failure, Success}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//Type declarations look like this: "nameOfObject:NameOfClass" with or without
 space.
\end_layout

\begin_layout Plain Layout

class LockingActor(printstr:String) extends Actor 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout

	var othermessagesanswered:Int = 0   
\end_layout

\begin_layout Plain Layout

	def receive =    
\end_layout

\begin_layout Plain Layout

	{     
\end_layout

\begin_layout Plain Layout

		case other: ActorRef =>     
\end_layout

\begin_layout Plain Layout

		{      
\end_layout

\begin_layout Plain Layout

			val response = other.ask("please reply")(50000)    //ask for response
 with timeout of 50 seconds   
\end_layout

\begin_layout Plain Layout

			response onComplete        
\end_layout

\begin_layout Plain Layout

			{          
\end_layout

\begin_layout Plain Layout

				case Success(result) => println("success: " + result)         
\end_layout

\begin_layout Plain Layout

				case Failure(failure) => println(failure)       
\end_layout

\begin_layout Plain Layout

			}       
\end_layout

\begin_layout Plain Layout

			othermessagesanswered += 1       
\end_layout

\begin_layout Plain Layout

			println(printstr + ": " + othermessagesanswered.toString())     
\end_layout

\begin_layout Plain Layout

		}     
\end_layout

\begin_layout Plain Layout

		case "please reply" =>     
\end_layout

\begin_layout Plain Layout

		{       
\end_layout

\begin_layout Plain Layout

			sender() ! "this is a reply"     
\end_layout

\begin_layout Plain Layout

		}     
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

object Main extends App 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout

    val system = ActorSystem("DemoSystem")       
\end_layout

\begin_layout Plain Layout

	val aActor = system.actorOf(Props(classOf[LockingActor], "a"))       
\end_layout

\begin_layout Plain Layout

	val bActor = system.actorOf(Props(classOf[LockingActor], "b"))       
\end_layout

\begin_layout Plain Layout

	for (x <- 0 to 100000)       
\end_layout

\begin_layout Plain Layout

	{        
\end_layout

\begin_layout Plain Layout

		println(x)         
\end_layout

\begin_layout Plain Layout

		Future{ aActor ! bActor }         
\end_layout

\begin_layout Plain Layout

		Future{ bActor ! aActor }              
\end_layout

\begin_layout Plain Layout

	} 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...
 will not deadlock.
 Moreover, the two actors will not even be in synchrony.
 Since they wait for each other with futures, they're not really waiting
 at all!
\end_layout

\begin_layout Subsection
Implementation
\end_layout

\begin_layout Standard
Akka actors have many interesting properties.
 For example, actor references are network aware, so one of our DemoActors
 could receive a message with an ActorRef to an actor on another continent
 and it would still respond correctly using the Akka Remote Protocol over
 TCP.
 Akka, unlike Erlang, enforces supervision in a similar manner as offered
 by Erlang's OTP.
\end_layout

\begin_layout Standard
Akka offers configurable message dispatchers, offering control over the
 number of underlying threads and number of messages an actor can process
 before the underlying thread jumps to the next actor.
 The default dispatcher uses a fork-join method to run the actors, but you
 can also use thread-pool or your own custom dispatcher.
\end_layout

\begin_layout Standard
Akka actors send messages as references by default, and unfortunately neither
 Java nor Scala enforces immutability of the underlying objects.
 To work around this, Akka provides optional deep copying of all messages.
\end_layout

\begin_layout Section
Occam
\begin_inset Index idx
status open

\begin_layout Plain Layout
Occam
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Unfortunately it proved troublesome to get one of the Occam compilers going
 - working with dead languages can be frustrating.
 Fortunately, many of the facilities offered in Occam can be replicated
 using other for example Futures and Actors in other languages.
\end_layout

\begin_layout Standard
For example this (admittedly completely paper-programmed) Occam snippet...
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "frame=lrtb,language=ML,numbers=left,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

#INCLUDE "hostio.inc" 
\end_layout

\begin_layout Plain Layout

#USE "hostio.lib" 
\end_layout

\begin_layout Plain Layout

PROC Main(CHAN OF SP fs,ts)
\end_layout

\begin_layout Plain Layout

	SEQ
\end_layout

\begin_layout Plain Layout

		PAR
\end_layout

\begin_layout Plain Layout

			x = function(1)
\end_layout

\begin_layout Plain Layout

			y = function(2)
\end_layout

\begin_layout Plain Layout

		z = x+y
\end_layout

\begin_layout Plain Layout

		so.write.string.int(fs, ts, z, 0)
\end_layout

\begin_layout Plain Layout

		so.exit(fs,ts,sps.success)
\end_layout

\begin_layout Plain Layout

:
\end_layout

\end_inset


\end_layout

\begin_layout Standard
...
 can be replicated in Scala like this using futures:
\begin_inset CommandInset label
LatexCommand label
name "Future example"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "frame=lrtb,language=scala,numbers=left"
inline false
status collapsed

\begin_layout Plain Layout

import scala.concurrent._ 
\end_layout

\begin_layout Plain Layout

import scala.concurrent.ExecutionContext.Implicits.global 
\end_layout

\begin_layout Plain Layout

import scala.concurrent.duration._ 
\end_layout

\begin_layout Plain Layout

import scala.language.postfixOps
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

object occ extends App 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout

	def function(i: Int) = i*i
\end_layout

\begin_layout Plain Layout

	val x = Future {function(1)}   
\end_layout

\begin_layout Plain Layout

	val y = Future {function(2)}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	val z = for   
\end_layout

\begin_layout Plain Layout

	{     
\end_layout

\begin_layout Plain Layout

		xc <- x     
\end_layout

\begin_layout Plain Layout

		yc <- y   
\end_layout

\begin_layout Plain Layout

	} yield xc + yc   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	val zval = Await.result(z, 0 nanos)   
\end_layout

\begin_layout Plain Layout

	println(zval) 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Obviously, this is a good deal more cumbersome than the Occam syntax and
 probably has more overhead, but the general idea of 
\begin_inset Quotes eld
\end_inset

do these things in parallel and then combine them
\begin_inset Quotes erd
\end_inset

 is alive and well, though modern replacements tend to be less streamlined
 for this purpose and have additional bells and whistles.
\end_layout

\begin_layout Section
Erlang with OTP
\begin_inset Index idx
status open

\begin_layout Plain Layout
Erlang
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
OTP
\end_layout

\end_inset


\end_layout

\begin_layout Quote
\begin_inset Quotes eld
\end_inset

Erlang is a programming language used to build massively scalable soft real-time
 systems with requirements on high availability.
 Some of its uses are in telecoms, banking, e-commerce, computer telephony
 and instant messaging.
 Erlang's runtime system has built-in support for concurrency, distribution
 and fault tolerance.
 [...] OTP is set of Erlang libraries and design principles providing middle-ware
 to develop these systems.
 It includes its own distributed database, applications to interface towards
 other languages, debugging and release handling tools.
\begin_inset Quotes erd
\end_inset

 - Erlang home page
\end_layout

\begin_layout Standard
Both Erlang and OTP were developed at Ericsson, and today are used for critical
 infrastructure worth multiples of billions, like WhatsApp.
 Insert snarky remark about capitalism here.
 OTP stands for Open Telephony Platform,
\begin_inset Index idx
status open

\begin_layout Plain Layout
OTP
\end_layout

\end_inset

 an archaic name not reflecting current use.
\end_layout

\begin_layout Subsection
Use
\end_layout

\begin_layout Standard
copy-on-send
\end_layout

\begin_layout Standard
state as recursion argument
\end_layout

\begin_layout Standard
flushing (timeout 0)
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,frame=lrtb,language=erlang,numbers=left,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

-module(kitchen).
 
\end_layout

\begin_layout Plain Layout

-compile(export_all).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

fridge2(FoodList) ->     
\end_layout

\begin_layout Plain Layout

	receive         
\end_layout

\begin_layout Plain Layout

		{From, {store, Food}} ->             
\end_layout

\begin_layout Plain Layout

			From ! {self(), ok},             
\end_layout

\begin_layout Plain Layout

			fridge2([Food|FoodList]);         
\end_layout

\begin_layout Plain Layout

		{From, {take, Food}} ->             
\end_layout

\begin_layout Plain Layout

			case lists:member(Food, FoodList) of                 
\end_layout

\begin_layout Plain Layout

				true ->                     
\end_layout

\begin_layout Plain Layout

					From ! {self(), {ok, Food}},                     
\end_layout

\begin_layout Plain Layout

					fridge2(lists:delete(Food, FoodList));                 
\end_layout

\begin_layout Plain Layout

				false ->                     
\end_layout

\begin_layout Plain Layout

					From ! {self(), not_found},                     
\end_layout

\begin_layout Plain Layout

					fridge2(FoodList)             
\end_layout

\begin_layout Plain Layout

				end;         
\end_layout

\begin_layout Plain Layout

		terminate ->             
\end_layout

\begin_layout Plain Layout

			ok     
\end_layout

\begin_layout Plain Layout

	end.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

store(Pid, Food) ->     
\end_layout

\begin_layout Plain Layout

	Pid ! {self(), {store, Food}},     
\end_layout

\begin_layout Plain Layout

	receive         
\end_layout

\begin_layout Plain Layout

		{Pid, Msg} -> Msg     
\end_layout

\begin_layout Plain Layout

	end.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

take(Pid, Food) ->     
\end_layout

\begin_layout Plain Layout

	Pid ! {self(), {take, Food}},     
\end_layout

\begin_layout Plain Layout

	receive         
\end_layout

\begin_layout Plain Layout

		{Pid, Msg} -> Msg     
\end_layout

\begin_layout Plain Layout

	end.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Implementation
\end_layout

\begin_layout Section
Go
\begin_inset Index idx
status open

\begin_layout Plain Layout
Go
\end_layout

\end_inset


\end_layout

\begin_layout Quote
\begin_inset Quotes eld
\end_inset

Go is expressive, concise, clean, and efficient.
 Its concurrency mechanisms make it easy to write programs that get the
 most out of multicore and networked machines, while its novel type system
 enables flexible and modular program construction.
 Go compiles quickly to machine code yet has the convenience of garbage
 collection and the power of run-time reflection.
 It's a fast, statically typed, compiled language that feels like a dynamically
 typed, interpreted language.
\begin_inset Quotes erd
\end_inset

 - Go documentation
\end_layout

\begin_layout Subsection
Use
\end_layout

\begin_layout Subsection
Implementation
\end_layout

\begin_layout Section
Rust
\begin_inset Index idx
status open

\begin_layout Plain Layout
Rust
\end_layout

\end_inset


\end_layout

\begin_layout Quote
\begin_inset Quotes eld
\end_inset

Rust provides safe concurrency through a combination of lightweight, memory-isol
ated tasks and message passing.
 [...] Rust tasks are not the same as traditional threads: rather, they are
 considered green threads, lightweight units of execution that the Rust
 runtime schedules cooperatively onto a small number of operating system
 threads.
 On a multi-core system Rust tasks will be scheduled in parallel by default.
 Because tasks are significantly cheaper to create than traditional threads,
 Rust can create hundreds of thousands of concurrent tasks on a typical
 32-bit system.
 In general, all Rust code executes inside a task, including the main function.
\begin_inset Quotes erd
\end_inset

 - Rust documentation
\end_layout

\begin_layout Standard
Rust is the newest and hottest language to be investigated here.
 Developed by Mozilla as a replacement for C++, its 1.0 spec is not even
 stable yet, but optional garbage collection and embeddability makes it
 very relevant for the embedded engineer of the near future.
 Semicolons mandatory.
\end_layout

\begin_layout Subsection
Use
\end_layout

\begin_layout Standard
Rust uses channels, futures and immutable copies.
 Channels are multi-sender, multi-receiver affairs, CSP-style:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,frame=lrtb,language={C++},numbers=left,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

fn main() 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout

	let (tx, rx) = channel();   
\end_layout

\begin_layout Plain Layout

	let txclone = tx.clone();
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	//proc denotes an anonymous function with function body being the stuff
 behind "proc()"
\end_layout

\begin_layout Plain Layout

	spawn(proc() tx.send("message"));
\end_layout

\begin_layout Plain Layout

	spawn(proc() txclone.send("another message"));      
\end_layout

\begin_layout Plain Layout

	spawn(proc() println!("{:s}, {:s}" ,rx.recv(), rx.recv()) ); 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Above, an example of how a two-sender single-receiver program is written.
 Now, the future
\begin_inset CommandInset label
LatexCommand label
name "Future example2"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,frame=lrtb,language={C++},numbers=left,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

use std::sync::Future;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

fn main()  
\end_layout

\begin_layout Plain Layout

{      
\end_layout

\begin_layout Plain Layout

	fn fib(n: u64) -> u64    
\end_layout

\begin_layout Plain Layout

	{     
\end_layout

\begin_layout Plain Layout

		// lengthy computation returning an uint     
\end_layout

\begin_layout Plain Layout

		12586269025   
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	let mut delayed_fib = Future::spawn(proc() fib(50)); 
\end_layout

\begin_layout Plain Layout

	println!("fib(50) = {}", delayed_fib.get());
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Implementation
\end_layout

\begin_layout Standard
When sending a message over a channel, the data in the message will be duplicate
d.
 To improve efficiency, multiple tasks can share an object as if on a shared
 heap, provided that the object is immutable.
\end_layout

\begin_layout Section
Esterel
\end_layout

\begin_layout Standard
Esterel may be the coolest implementation discussed here.
 It has very limited expressive power and is not freely available, but it
 has 
\emph on
exciting
\emph default
 properties: Threads in Esterel 
\emph on
execute in synchronous time
\emph default
.
 Put diferently, Esterel has a global clock that threads march in lockstep
 to! A thread has a loop and one cycle of that loop is ompleted per tick
 of the global clock.
 Esterel is completely deterministic; neither dynamic memory nor spawning
 of processes are supported.
 Signals are broadcast, and threads await and send signals.
 A signal is either precent in a cycle or it is not - the time of broadcast
 is abstracted away.
 Programs in Esterel are deterministic finite state machines.
\end_layout

\begin_layout Standard
Esterel is not a real-time language but since it is completely deterministic,
 simple testing should suffice for investigating time characteristics.
\end_layout

\begin_layout Section
Simulink
\end_layout

\begin_layout Standard
data transfer
\end_layout

\begin_layout Section
Modelica
\end_layout

\begin_layout Section
LabView
\end_layout

\begin_layout Standard
LabView uses pipelining.
\end_layout

\begin_layout Section
Existing C message-passing implementations
\end_layout

\begin_layout Itemize
https://github.com/tylertreat/chan
\end_layout

\begin_layout Itemize
libthread
\end_layout

\begin_layout Itemize
CSP for C
\end_layout

\begin_layout Section
Concepts
\end_layout

\begin_layout Subsection
Thread Pool
\begin_inset Index idx
status open

\begin_layout Plain Layout
thread pool
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A pool of real threads
\begin_inset Index idx
status open

\begin_layout Plain Layout
real threads
\end_layout

\end_inset

, POSIX or otherwise, each thread able to be executed directly on the processor.
 The notion of 
\begin_inset Quotes eld
\end_inset

real
\begin_inset Quotes erd
\end_inset

 thread may be extended to more abstract concurrency concepts like Java
 threads
\begin_inset Index idx
status open

\begin_layout Plain Layout
Java threads
\end_layout

\end_inset

, since they map directly to OS threads.
 This pool of real threads are then used to execute lightweight or virtual
 threads.
 These lightweight threads
\begin_inset Index idx
status open

\begin_layout Plain Layout
lightweight threads
\end_layout

\end_inset

 are in reality only tasks for the real threads to execute.
\end_layout

\begin_layout Subsection
Dispatching
\end_layout

\begin_layout Standard
How work tasks are given to the real threads.
\end_layout

\begin_layout Subsection
Thread-pool dispatching
\begin_inset Index idx
status open

\begin_layout Plain Layout
thread-pool dispatching
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The tasks to be run are divided into groups of assumed equal load and given
 to the real threads for execution.
 This method is divided into first a divide and then a conquer phase.
 If one group of tasks turns out to take longer than another the real thread
 with the easier task group is left idling.
\end_layout

\begin_layout Subsection
Fork-join dispatching
\begin_inset Index idx
status open

\begin_layout Plain Layout
fork-join dispatching
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Fork-join is similar to thread-pool, but uses something called work stealing.
 With work stealing, a thread that finishes its tasks early can 
\begin_inset Quotes eld
\end_inset

steal
\begin_inset Quotes erd
\end_inset

 tasks from a thread that's still busy.
 What happens is that the tasks are grouped in a single group and pushed
 on a stack.
 Each real thread can then pop a group of task and either split the group
 and push the resulting groups or execute the group.
 In general, real threads will only execute very small groups, splitting
 groups instead if they're too large.
 Task groups should be considered small enough when the expected overhead
 of worrying about their size is larger than the expected cost of a single
 group being too large.
 The benefit of this method over thread-pool is that the divide and conquer
 phases are interleaved.
 There are a lot more task groups than threads, so a misjudgment of the
 complexity of a single task group should have smaller consequence.
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

work stealing
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
work stealing
\end_layout

\end_inset

 term comes from an alternative implementation where the N real threads
 split the tasks into N task groups which each real thread finally splits
 and places on its own work stack.
 Once a real thread is done with its own task groups it will try to steal
 task groups from other real thread's stacks.
 If there's no work to find there it will look to an input queue of work
 common to all N real threads.
\end_layout

\begin_layout Subsection
Future 
\begin_inset Index idx
status open

\begin_layout Plain Layout
future
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A future is an [insert value here]-value.
 It represents the result of a computation that may or may not have finished
 yet.
 It's a feature for requesting a computation and getting the results (including
 side effects) later.
 For examples, see 
\begin_inset CommandInset ref
LatexCommand ref
reference "Future example"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "Future example2"

\end_inset

.
 
\end_layout

\begin_layout Subsection
Channel 
\begin_inset Index idx
status open

\begin_layout Plain Layout
channel
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A channel is a communication primitive between threads.
 A channel, as used in Go, Rust and CSP, can have several senders and recipients.
 Each message can typically only be received once, so multiple receivers
 is not a broadcast mechanism, but rather a work division mechanism.
\end_layout

\begin_layout Subsection
Immutability 
\begin_inset Index idx
status open

\begin_layout Plain Layout
immutability
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If an object or value is immutable it means it can't be changed.
 Depending on whom you ask, this might mean that only the object itself
 need be unchangeable, or it could mean that the object and all the objects
 it references are unchangeable.
 To avoid the ambiguity, terms like 
\begin_inset Quotes eld
\end_inset

deeply immutable
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

invariant
\begin_inset Quotes erd
\end_inset

 can be used for the latter.
 Objects or values that are deeply immutable can be shared between threads
 without fear of adverse effects, which make this property very attractive.
\end_layout

\begin_layout Subsection
Pipe
\end_layout

\begin_layout Standard
A pipe is a single sender, single receiver, one-way and asynchronous communicati
ons channel between threads.
\end_layout

\begin_layout Subsection
Coroutine
\end_layout

\begin_layout Standard
Coroutines are a superclass of subroutines, what we ordinarliy call functions,
 and are mostly written the same way.
 While a function is called and then returns, with a clear caller-callee
 relationship, coroutines can yield and receive execution as many times
 as desired during its lifetime.
 Functions, to contrast, 
\begin_inset Quotes eld
\end_inset

resume
\begin_inset Quotes erd
\end_inset

 at the beginning and yield at the end.
 Coroutines are so called because they do co-operative scheduling - yielding
 is entirely voluntary and predictable on the part of the coroutine.
 Coroutines were first done in Assembly by Melvin Conway in 1958, and it's
 easy to understand why - yielding in assembly can be done by simply doing
 a jumping into another 
\begin_inset Quotes eld
\end_inset

coroutine
\begin_inset Quotes erd
\end_inset

.
 Actually, Assembly usually has no concept of functions, let alone coroutines,
 so you just jump to somewhere else in program memory.
\end_layout

\begin_layout Subsubsection
Disadvantages
\end_layout

\begin_layout Standard
Coroutines have co-operative scheduling, which is cheap compared to pre-emptive
 but that means we're reliant on the programmer for parallelism.
 Any coroutine can hog procesing capacity for as long as it likes.
 Also, real threads don't share stack, so state held in stack somehow needs
 to be synchronised across threads.
\end_layout

\begin_layout Subsubsection
Problems in C
\end_layout

\begin_layout Standard
I've decided to provide you with a basic example of the mechanisms used.
 Here we have two functions, co1 and co2, pass control between one another,
 saving each other's positions on the stack in global environment variables.
 The variables need to be global, because jumping to a function higher up
 on the stack will mess up any variable, even const pointers, held on the
 stack in that function.
 It's probably the same for all functions higher up on the stack, but I
 haven't tested.
 That gave me some weird bug behaviour that was pretty hard to figure out.
 It's worth pointing out that the behaviour of longjumping to a function
 that is not the caller of the current function is 
\emph on
undefined
\emph default
; this is abuse of longjmp, but it is not unprecedented and does work.
 An alternative would be using Boost.context from the Boost library for C++.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,extendedchars=true,frame=lrtb,language=C,numbers=left,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#include <setjmp.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static jmp_buf environment1;
\end_layout

\begin_layout Plain Layout

static jmp_buf environment2;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

__attribute__ ((noreturn)) static void co2()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  int VAR = 5;
\end_layout

\begin_layout Plain Layout

  printf("VAR = %d
\backslash
n", VAR);
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  printf("In function co2 place 1
\backslash
n");
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  int ret = setjmp(environment2);
\end_layout

\begin_layout Plain Layout

  if (ret == 0)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    longjmp(environment1, 1);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  printf("In function co2 place 2
\backslash
n");
\end_layout

\begin_layout Plain Layout

  ret = setjmp(environment2);
\end_layout

\begin_layout Plain Layout

  if (ret == 0)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    longjmp(environment1, 1);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  printf("In function co2 place 3
\backslash
n");
\end_layout

\begin_layout Plain Layout

  printf("VAR = %d
\backslash
n", VAR);
\end_layout

\begin_layout Plain Layout

  longjmp(environment1, 1);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

static void co1()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  printf("In function co1 place 1
\backslash
n");
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  int ret = setjmp(environment1);
\end_layout

\begin_layout Plain Layout

  if (ret == 0)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    co2();
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  printf("In function co1 place 2
\backslash
n");
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  ret = setjmp(environment1);
\end_layout

\begin_layout Plain Layout

  if (ret == 0)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    longjmp(environment2, 1);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  printf("In function co1 place 3
\backslash
n");
\end_layout

\begin_layout Plain Layout

  ret = setjmp(environment1);
\end_layout

\begin_layout Plain Layout

  if (ret == 0)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

    longjmp(environment2, 1);
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    printf("Hello World
\backslash
n");
\end_layout

\begin_layout Plain Layout

    co1();
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The output is as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,frame=lrtb,numbers=left"
inline false
status open

\begin_layout Plain Layout

Hello World 
\end_layout

\begin_layout Plain Layout

In function co1 place 1 
\end_layout

\begin_layout Plain Layout

VAR = 5 
\end_layout

\begin_layout Plain Layout

In function co2 place 1 
\end_layout

\begin_layout Plain Layout

In function co1 place 2 
\end_layout

\begin_layout Plain Layout

In function co2 place 2 
\end_layout

\begin_layout Plain Layout

In function co1 place 3 
\end_layout

\begin_layout Plain Layout

In function co2 place 3 
\end_layout

\begin_layout Plain Layout

VAR = 0 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Observe that the integer variable VAR changes value without ever having
 been touched since creation in the source code.
 Not only can we not synchronise stack state between real threads, we can't
 even keep it within one real thread.
 As explained, coroutines can be done with jumps, but stack variables are
 not conserved.
 At least not without using costly system calls or complicated assembly
 voodoo, which most lightweight thread libraries for C seems to use.
 This means that the normal way of programming will have to be constrained
 a bit - all variables will have to be held on the heap or in global variables.
\end_layout

\begin_layout Subsubsection
How it may be used to create general-purpose lightweight threads
\end_layout

\begin_layout Standard
Coroutines as hereto discussed might make some code more readable (especially
 consumer-producer relationships), but it does not help us create lightweight
 threads of the kind we want.
 But what if the coroutine didn't yield to another coroutine but to a scheduler?
 Indeed, this is how goroutines work in Go, although Go hides so much of
 the manual scheduling work that its authors decided to exchange c for g
 in the name to avoid confusion.
 
\end_layout

\begin_layout Standard
A possible way to use coroutines to achieve lightweight threads would be
 to have each lightweight thread be a function pointer and a struct held
 on heap where state can be saved.
 The function yields each time it awaits a message and when it is done.
 When a function yields, the executing thread goes back to the scheduler
 and starts or resumes another function.
 Messages are received through a special value in the struct.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
The popular approaches taken to concurrency in modern languages can be roughly
 divided into two: The actor model and CSP.
 The two approaches come from different mindsets and priorities.
 Users of the actor model often use it to create distributed, parallel,
 fault-tolerant systems.
 Users of CSP often want lower-level concurrency mechanisms that are easier
 to reason about and more predictable.
 
\end_layout

\begin_layout Paragraph
The differences between CSP and actor model
\end_layout

\begin_layout Itemize
CSP threads are anonymous, actors are named.
\end_layout

\begin_layout Itemize
CSP communication is synchronous, actor communication is asynchronous.
\end_layout

\begin_layout Itemize
CSP communication is multi-sender, multi-receiver, actor communication is
 one-to-one.
\end_layout

\begin_layout Part
Proposal for C
\end_layout

\begin_layout Standard
A recurring theme in discussing these topics online seems to be a need for
 predictability.
 POSIX threads are not predictable, but are or may be perceived as more
 predictable than lightweight threads with lots of stuff happening underneath
 in a non-obvious manner.
\end_layout

\begin_layout Standard
I propose an implementation that is as simple and deterministic as possible,
 providing guarantees like 
\begin_inset Quotes eld
\end_inset

all threads get to run a decent amout
\begin_inset Quotes erd
\end_inset

.
 Exposed functionality should be something like:
\end_layout

\begin_layout Enumerate
Parmap, a very simple mapping of one array to another of type 
\begin_inset Formula $arrayA[x]=f(arrayB[x])$
\end_inset

 for all elements x.
 Executed in parallel.
\end_layout

\begin_layout Enumerate
Futures, parallel computation
\end_layout

\begin_layout Enumerate
Lightweight threads with channels.
\end_layout

\begin_layout Section
How to implement lightweight threads
\end_layout

\begin_layout Standard
\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-2"

\end_inset

http://doc.rust-lang.org/0.11.0/guide-tasks.html
\end_layout

\end_body
\end_document
