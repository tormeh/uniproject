#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\lstdefinelanguage{scala}
{
 morekeywords={abstract,case,catch,class,def,%
    do,else,extends,false,final,finally,%
    for,if,implicit,import,match,mixin,%
    new,null,object,override,package,%
    private,protected,requires,return,sealed,%
    super,this,throw,trait,true,try,%
    type,val,var,while,with,yield},
  otherkeywords={=>,<-,<\%,<:,>:,\#,@},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Light Weight Threads and Their Synchronization Primitives
\end_layout

\begin_layout Author
Tormod Hellen
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newpage
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Evaluation note
\end_layout

\begin_layout Standard
I want to be evaluated on both this report and the attached C code.
 
\end_layout

\begin_layout Part
Goals
\end_layout

\begin_layout Standard
The goals of this project is to:
\end_layout

\begin_layout Enumerate
Give a desciption of the paradigms relevant to safe concurrency
\end_layout

\begin_layout Enumerate
Present the leading edge of implementations and other things that should
 influence a modern concurrency abstraction framework
\end_layout

\begin_layout Enumerate
Give an overview over how threads, channels etc.
 are implemented in modern implementations
\end_layout

\begin_layout Enumerate
Propose a solution for concurrency in C
\end_layout

\begin_layout Enumerate
Prototype the solution mentioned
\end_layout

\begin_layout Part
Background
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
There are many models of concurrency awailable to the modern engineer.
 The classic semaphore and its relative - lock - are the most native to
 the way our processors look, with shared memory between thread hardware.
 Others, like the actor model, copy a distributed architecture with several
 computers, all with their own memory, processors and network connections.
 Others still, like channel-concurrency, are based on formal or mathematical
 theorems.
 These are the three main means of concurrency, though others have been
 introduced.
 We will look at some of them here.
\end_layout

\begin_layout Subsection
Tl;DR
\end_layout

\begin_layout Itemize

\emph on
Semaphore
\emph default
: C, C++, Java etc.
 implement this style of concurrency.
 
\end_layout

\begin_deeper
\begin_layout Itemize
STM: Software Transactional Memory, or, for some architectures, simply Transacti
onal Memory, is a kind of optimistic semaphore technique where changes are
 rolled back and attempted again in case of conflict.
 Coupled with language features that prevent the sharing of non-transactional
 memory between threads it is a convenient, but computationally costly technique.
 Haskell, Clojure and Akka implement this.
 
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Channel
\emph default
: This is the CSP family and its derivatives.
 Go, Rust and Occam have concurrency mechanisms based on channels.
 Focus on being deterministic and formally analyzable.
 Uses multi-sender, multi-receiver (first to read) synchronous channels.
\end_layout

\begin_layout Itemize

\emph on
Actor
\emph default
: Erlang and Akka implement this model.
 Intuitively suited for making distributed systems, with a focus on fault
 tolerance rather than fault avoidance.
 Both implementations eschew sophisticated error recovery mechanisms and
 instead prefer crashing and rebooting errant processes, a philosophy called
 
\begin_inset Quotes eld
\end_inset

let it crash
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
Pipelining: LabView uses this.
 Each thread has one or more pipelines to and from other threads.
 Uses one-way, single sender, single receiver message passing called pipes.
\end_layout

\begin_layout Itemize
Synchronous execution: Threads execute in synchrony, resulting in complete
 determinism.
 Esterel uses this.
\end_layout

\begin_layout Itemize
Lightweight threads that are less omputationally costly to deal with.
\end_layout

\begin_layout Section
Limitations
\end_layout

\begin_layout Standard
Rust is the newest and hottest language investigated in this project.
 It's developed by Mozilla as a replacement for C++.
 Rust 
\emph on
used to have
\emph default
 only lightweight threads, but due to the many features desirable for threads
 in Rust (ability to call C code etc.) the lightweight threads ended up being
 as heavy to run as OS threads, and Rust's lightweight threads have been
 pushed to a library outside the standard library.
 This illustrates an important point: OS threads are not heavyweight just
 to irritate us, they are heavyweight because they have features lightweight
 threads don't.
 Tradeoffs are necessary.
 There is no free lunch.
 This is also true for the synchronization abstractions.
\end_layout

\begin_layout Standard
Let there be no mistake: In switching from OS threads with semaphores to
 any of the higher abstractions we sacrifice flexibility, performance and
 features for the sake of safety and ease of programming.
 That's the disclaimer.
 Now for the good part: The end result can still be more performant and
 do more complicated things because the safety and ease of use lets us program
 less conservatively.
 It's a bit like going from a low-level language to a high-level one.
\end_layout

\begin_layout Section
Lightweight threads and synchronization
\end_layout

\begin_layout Standard
Lightweight threads and synchronization mechanisms are different things
 not really intimately linked
\end_layout

\begin_layout Section
The nature of a lightweight thread
\end_layout

\begin_layout Paragraph
Process > OS Thread > Lightweight Thread
\end_layout

\begin_layout Standard
OS threads are actually themselves lightweight when compared to another
 popular concurrency abstraction: processes.
 All processes run concurrently anyway, and moving information between them
 with inter-process communication (example: localhost) you suddenly have
 a heavyweight actor model: All that's old is new again, it seems.
 My point is that the quest for more efficient means of concurrency is hardly
 new, though it has acquired unusual urgency as single-core processor performanc
e gains are slowing down.
\end_layout

\begin_layout Paragraph
What does a lightweight thread look like? 
\end_layout

\begin_layout Standard
Well, the point of a lightweight thread is to be light - it can't have all
 the things an OS thread does.
 A POSIX thread holds the following things in memory
\begin_inset CommandInset citation
LatexCommand cite
key "key-1"

\end_inset

:
\end_layout

\begin_layout Itemize
Stack pointer 
\end_layout

\begin_layout Itemize
Registers 
\end_layout

\begin_layout Itemize
Scheduling properties (such as policy or priority) 
\end_layout

\begin_layout Itemize
Set of pending and blocked signals 
\end_layout

\begin_layout Itemize
Thread specific data such as the current execution stack.
\end_layout

\begin_layout Standard
Collectively, these things are called a thread context.
 A context switch is when a processor core pauses, switches its registers,
 points its stack pointer and program counter at the right memory adresses
 etc.
 and starts executing again.
 So lightweight threads, in order to be lightweight, have to sustain themselves
 on less than a thread context and/or have faster context switches, which
 are two goals with overlapping means.
 There are many ways from here: 
\end_layout

\begin_layout Itemize
Go's goroutines have no signals, but they do have a stack.
 The stack starts small and, like a vector, can be expanded by allocating
 a piece of memory somewhere else.
 By having a stack, goroutines are a bit like normal threads as they can
 be resumed after a pause.
\end_layout

\begin_layout Itemize
Akka's actors have no stack.
 How do they work then? The Java thread runs the actor's receive function
 until completion and then the stack is thrown away as the Java thread moves
 on to another actor.
 Clever and simple, but it requires a different way of programming than
 we're used to.
 See? Tradeoffs.
\end_layout

\begin_layout Section
CSP Theory
\end_layout

\begin_layout Standard
This part is strictly optional.
 The Communicating Sequential Processes theory describes a way for parallel
 computation to be done in which the traditional shared-memory errors like
 race conditions are not possible.
 CSP introduces processes and events.
\end_layout

\begin_layout Section
Semaphores
\end_layout

\begin_layout Section
Channels
\end_layout

\begin_layout Section
Actors
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,frame=lrtb,language=scala,numbers=left"
inline false
status open

\begin_layout Plain Layout

import akka.actor.Actor 
\end_layout

\begin_layout Plain Layout

import akka.actor.ActorRef 
\end_layout

\begin_layout Plain Layout

import akka.actor.ActorSystem 
\end_layout

\begin_layout Plain Layout

import akka.actor.Props 
\end_layout

\begin_layout Plain Layout

import scala.sys 
\end_layout

\begin_layout Plain Layout

import java.lang.Thread
\end_layout

\begin_layout Plain Layout

//Type declarations look like this: "nameOfObject:NameOfClass" with or without
 space.
\end_layout

\begin_layout Plain Layout

class DemoActor(printstr:String) extends Actor 
\end_layout

\begin_layout Plain Layout

{  
\end_layout

\begin_layout Plain Layout

  def receive = 
\end_layout

\begin_layout Plain Layout

  {     
\end_layout

\begin_layout Plain Layout

    case other: ActorRef =>
\end_layout

\begin_layout Plain Layout

    {     	
\end_layout

\begin_layout Plain Layout

      println(printstr)     	
\end_layout

\begin_layout Plain Layout

      other ! self      
\end_layout

\begin_layout Plain Layout

    }     
\end_layout

\begin_layout Plain Layout

    case _       => println("unknown message")   
\end_layout

\begin_layout Plain Layout

  } 
\end_layout

\begin_layout Plain Layout

}   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

object Main extends App 
\end_layout

\begin_layout Plain Layout

{   
\end_layout

\begin_layout Plain Layout

  val system = ActorSystem("DemoSystem")     
\end_layout

\begin_layout Plain Layout

  val aActor = system.actorOf(Props(classOf[DemoActor], "a"))   
\end_layout

\begin_layout Plain Layout

  val bActor = system.actorOf(Props(classOf[DemoActor], "b"))   
\end_layout

\begin_layout Plain Layout

  aActor ! bActor   
\end_layout

\begin_layout Plain Layout

  Thread.sleep(3)   //let actors run for 3 milliseconds
\end_layout

\begin_layout Plain Layout

  scala.sys.exit() 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Synchronous Execution
\end_layout

\begin_layout Section
Pipelining
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "llnl.gov pthreads"
key "key-1"

\end_inset

https://computing.llnl.gov/tutorials/pthreads/
\end_layout

\begin_layout Standard
\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"

\end_inset


\end_layout

\end_body
\end_document
